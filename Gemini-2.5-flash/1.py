import random

# Константы для отображения лабиринта
WALL = '#'
PATH = ' '
START = 'S'
END = 'E'

def generate_maze(rows, cols):
    """
    Генерирует лабиринт заданного размера (rows x cols)
    с использованием алгоритма рекурсивного обхода в глубину (DFS).
    """
    # Размеры реальной сетки лабиринта (включая стены вокруг и между ячейками)
    # Если логический лабиринт 3x3, то реальный будет (2*3+1)x(2*3+1) = 7x7
    # Пример: # # # # # # #
    #         # P # P # P #
    #         # # # # # # #
    #         # P # P # P #
    #         # # # # # # #
    #         # P # P # P #
    #         # # # # # # #
    grid_rows = rows * 2 + 1
    grid_cols = cols * 2 + 1

    # Инициализируем всю сетку как стены
    maze = [[WALL for _ in range(grid_cols)] for _ in range(grid_rows)]

    # Массив для отслеживания посещенных логических ячеек
    # Это логический лабиринт rows x cols, а не физический
    visited = [[False for _ in range(cols)] for _ in range(rows)]

    # Относительные координаты для перемещения: Север, Юг, Запад, Восток
    dr = [-1, 1, 0, 0] # изменения по строкам
    dc = [0, 0, -1, 1] # изменения по столбцам

    def carve_path(r, c):
        """
        Рекурсивная функция для прокладывания пути из текущей ячейки (r, c).
        r, c здесь - координаты логической ячейки (0 до rows-1, 0 до cols-1).
        """
        # Отмечаем текущую логическую ячейку как посещенную
        visited[r][c] = True

        # Отмечаем соответствующую физическую ячейку в лабиринте как проход
        # Физическая ячейка для логической (r, c) находится по адресу (2*r+1, 2*c+1)
        maze[r * 2 + 1][c * 2 + 1] = PATH

        # Создаем список возможных направлений (0=С, 1=Ю, 2=З, 3=В) и перемешиваем их
        # Это обеспечивает случайный выбор следующего направления
        directions = list(range(4))
        random.shuffle(directions)

        # Пробуем каждое направление
        for i in directions:
            nr, nc = r + dr[i], c + dc[i] # Координаты соседней логической ячейки

            # Проверяем, находится ли соседняя ячейка в пределах лабиринта
            # и не была ли она ранее посещена
            if 0 <= nr < rows and 0 <= nc < cols and not visited[nr][nc]:
                # Если да, то удаляем стену между текущей и соседней ячейками
                # Стена находится ровно посередине между их физическими координатами
                wall_r = r * 2 + 1 + dr[i]
                wall_c = c * 2 + 1 + dc[i]
                maze[wall_r][wall_c] = PATH

                # Рекурсивно вызываем функцию для соседней ячейки
                carve_path(nr, nc)

    # Начинаем прокладывать путь из случайной стартовой ячейки
    start_r, start_c = random.randint(0, rows - 1), random.randint(0, cols - 1)
    carve_path(start_r, start_c)

    # Добавляем стартовую и конечную точки в лабиринт
    # Обычно это (1,1) и (grid_rows-2, grid_cols-2) для удобства
    maze[1][1] = START
    maze[grid_rows - 2][grid_cols - 2] = END

    return maze

def print_maze(maze):
    """
    Выводит сгенерированный лабиринт в консоль.
    """
    for row in maze:
        print("".join(row))

if __name__ == "__main__":
    # Задайте желаемые размеры лабиринта
    maze_rows = 15  # Количество логических строк ячеек
    maze_cols = 30  # Количество логических столбцов ячеек

    if maze_rows <= 0 or maze_cols <= 0:
        print("Размеры лабиринта должны быть положительными числами.")
    else:
        print(f"Генерируем лабиринт {maze_rows}x{maze_cols}...")
        generated_maze = generate_maze(maze_rows, maze_cols)
        print_maze(generated_maze)
        print("\nЛегенда: #=Стена, ' '=Проход, S=Старт, E=Финиш")